  Нуриев Рамазан Ришатович,11-306. Вариант 3(теория).


Вопрос 1)Что такое абстрактный класс в Java?

В Java абстрактный класс — это класс, который содержит хотя бы один абстрактный метод. 
Абстрактный метод — это метод без тела, то есть без реализации в самом классе. 
Абстрактные классы создаются с использованием ключевого слова abstract.
Абстрактные классы не могут быть инстанциированы напрямую. 
Они предназначены для того, чтобы служить базовым классом для других классов. 
Класс, который наследует абстрактный класс, должен предоставить реализацию всех абстрактных методов или также быть объявлен как абстрактный.

  Пример кода(абстрактный класс):
abstract class АбстрактныйКласс {
    // Абстрактный метод (без реализации)
    abstract void абстрактныйМетод();

    // Обычный метод с реализацией
    void обычныйМетод() {
        System.out.println("Это обычный метод.");
    }
}

  Пример кода(Класс, который наследует абстрактный класс):
class КонкретныйКласс extends АбстрактныйКласс {
    // Реализация абстрактного метода
    @Override	
    void абстрактныйМетод() {
        System.out.println("Это реализация абстрактного метода.");
    }
}



Вопрос 2)В чём отличие интерфейса от абстрактного класса?

Интерфейс и абстрактный класс в Java предоставляют различные механизмы для реализации абстракции и наследования. Вот основные отличия между ними:
 	Абстрактный класс:
Может содержать как абстрактные методы (без реализации), так и обычные методы с реализацией.
Может иметь поля (переменные класса).
Может иметь конструктор.
Один класс может наследоваться только от одного абстрактного класса.

  Пример кода (абстрактный класс):
abstract class АбстрактныйКласс {
    // Абстрактный метод (без реализации)
    abstract void абстрактныйМетод();

    // Обычный метод с реализацией
    void обычныйМетод() {
        System.out.println("Это обычный метод.");
    }
}
	Интерфейс:
Может содержать только абстрактные методы и константы (переменные, которые автоматически считаются public, static, и final).
Не может содержать обычные методы с реализацией, но можно включать методы с реализацией (default methods и static methods).
Не может иметь полей (переменных экземпляра).
Класс может реализовывать несколько интерфейсов.

  Пример кода (интерфейс):
interface Интерфейс {
    void абстрактныйМетод();

    default void методСРеализацией() {
        System.out.println("Это метод с реализацией.");
    }
}



Вопрос 3)Каким образом в Java реализуется композиция?

В Java композиция реализуется путем включения одного объекта в другой в качестве поля. 
Это означает, что один класс состоит из объектов другого класса, и объекты внутреннего класса используются для предоставления функциональности внешнему классу. 
В отличие от наследования, где класс расширяет другой класс, при композиции классы просто содержат друг друга.

	Пример кода(композиция):
public class Двигатель {
    void запустить() {
        System.out.println("Двигатель запущен.");
    }
}

// Внешний класс, использующий композицию
class Автомобиль {
    private Двигатель двигатель; // Поле типа Двигатель

    // Конструктор, инициализирующий объект Двигатель
    public Автомобиль() {
        this.двигатель = new Двигатель();
    }

    void завести() {
        System.out.println("Автомобиль заведен.");
        двигатель.запустить(); // Используем объект Двигатель для запуска двигателя
    }
}



Вопрос 4)Что такое статический и динамический полиморфизм в Java?

Полиморфизм — это принцип, который позволяет объектам одного и того типа использоваться с общим интерфейсом, при этом конкретная реализация методов может различаться.
В Java полиморфизм реализуется через статический и динамический полиморфизм, используя перегрузку методов и переопределение методов.

1. Статический полиморфизм:
   - Реализуется с помощью перегрузки методов (overloading).
   - Решение о том, какой метод вызывать, принимается на этапе компиляции.
   - При перегрузке методов в одном классе или интерфейсе можно иметь несколько методов с одним и тем же именем, но разными параметрами.
   
	Пример статического полиморфизма:
   class Пример {
       // Перегрузка методов
       int сложить(int a, int b) {
           return a + b;
       }
       double сложить(double a, double b) {
           return a + b;
       }
   }
В этом примере, в зависимости от типов аргументов, компилятор выберет подходящий метод.

2. Динамический (время выполнения) полиморфизм:
   - Реализуется с использованием наследования и переопределения методов (overriding).
   - Решение о том, какой метод вызывать, принимается во время выполнения программы.
   - В Java динамический полиморфизм достигается через использование ключевого слова `override` при переопределении метода в подклассе.
   
	Пример динамического полиморфизма:
   class Фигура {
       void нарисовать() {
           System.out.println("Рисуем фигуру");
       }
   }

   class Круг extends Фигура {
       @Override
       void нарисовать() {
           System.out.println("Рисуем круг");
       }
   }

   class Прямоугольник extends Фигура {
       @Override
       void нарисовать() {
           System.out.println("Рисуем прямоугольник");
       }
   }
В данном примере метод нарисовать() переопределен в подклассах. При вызове метода на объекте типа Фигура, фактический метод, который будет выполнен, будет определен во время выполнения в зависимости от фактического типа объекта.



Вопрос 5)Каково значение ключевого слова super в Java?

В Java ключевое слово super используется для обращения к членам родительского класса внутри подкласса. 
super может использоваться для выполнения следующих задач:

1. Обращение к членам родительского класса:
   class Родитель {
       int значение = 10;

       void метод() {
           System.out.println("Метод в родительском классе");
       }
   }

   class Подкласс extends Родитель {
       void использованиеКлючевогоСловаСупер() {
           System.out.println(super.значение); // Обращение к полю родительского класса
           super.метод(); // Вызов метода родительского класса
       }
   }

2. Вызов конструктора родительского класса:
   class Родитель {
       Родитель(int значение) {
           // инициализация
       }
   }

   class Подкласс extends Родитель {
       Подкласс(int значение) {
           super(значение); // Вызов конструктора родительского класса
           // дополнительная инициализация
       }
   }
 


